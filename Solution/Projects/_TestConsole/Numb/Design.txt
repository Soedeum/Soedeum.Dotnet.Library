root    => set trees root to this node
branch  => a new node point
leaf    => a terminal node
tree    => a tree rule
list    => a list of nodes


tree Numb on Numb.n := list a as Assignment;                        ;; <Numb> -> [0]: {<Assignment>}

tree Assignment on Assignment.a := leaf v, branch e as Equation;    ;; <Assignment> -> [0]: (Variable) 

tree Equation on Equation.e := branch t as Term, list ts as (leaf o, branch t as Term);

tree Term on Term.t:= if t 
                        is Variable.v      then leaf v
                        is Number.n        then leaf n
                        is EnclosedTerm.et then branch et as EnclosedTerm;

tree EnclosedTerm on EnclosedTerm.e := leaf s, branch e as Equation;



rule Numb := {Assignment}.a ;

rule Assignment := Variable.v Assignment.a Equation.e Semicolon.s;

rule Equation := Term.t {Operator.o Term.t}.ts ;

rule Operator := (Plus or Minus or Times or DivideBy or Exponent) ;

rule Term := (Variable or Number or EnclosedTerm) ;

rule EnclosedTerm := [Sign].s OpenParentheses.op Equation.e CloseParentheses.cp ;

rule Sign := (Plus or Minus) ;


token Number :=  Integer [ '.' +{numeric}  ] [ ('E' or 'e') Integer ] ;

subtoken Integer := ['+' or '-'] +{numeric} ;

token Variable := (Alpha or '_') +{alphanumeric or '_'} ;

token Plus := '+' ;

token Minus := '-' ;

token Times := '*' ;

token DivideBy := '/' ;

token PowerOf := '^' ;        

token Assign := ':=' ;

token OpenParentheses := '(' ;

token CloseParentheses := ')' ;

token Semicolon := ';' ;

skiptoken Whitespace := {whitespace} ;

skiptoken LineComment := '#'  ;


charset comment := not (eol or eof) ;

charset numeric := '0' to '9' ;

charset alpha := 'A' to 'Z' or 'a'..'z' ;

charset alphanumeric := alpha or numeric ;

charset eol := '\r' or '\n'

charset eof := '\0';

charset whitespace := ' ' or '\t' or eol ;
